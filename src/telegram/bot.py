"""
Telegram Bot for publishing F1 news
"""
import asyncio
from typing import List, Optional, Dict, Any
from datetime import datetime
import logging

from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram.constants import ParseMode

from ..models import ProcessedNewsItem, PublicationResult
from ..config import settings

logger = logging.getLogger(__name__)

class F1NewsBot:
    """Telegram Bot for F1 news publication"""
    
    def __init__(self):
        self.bot = Bot(token=settings.telegram_bot_token)
        self.application = None
        self.channel_id = settings.telegram_channel_id
        self.pending_publications = []
    
    async def initialize(self):
        """Initialize the bot"""
        try:
            self.application = Application.builder().token(settings.telegram_bot_token).build()
            
            # Add handlers
            self.application.add_handler(CommandHandler("start", self.start_command))
            self.application.add_handler(CommandHandler("help", self.help_command))
            self.application.add_handler(CommandHandler("status", self.status_command))
            self.application.add_handler(CommandHandler("queue", self.queue_command))
            self.application.add_handler(CommandHandler("publish", self.publish_command))
            self.application.add_handler(CallbackQueryHandler(self.button_callback))
            
            logger.info("Telegram bot initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize Telegram bot: {e}")
            return False
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        welcome_message = """
üèéÔ∏è **F1 News Bot** üèéÔ∏è

–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ F1 –Ω–æ–≤–æ—Å—Ç–µ–π!

**–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**
/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É
/status - –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
/queue - –ü–æ–∫–∞–∑–∞—Ç—å –æ—á–µ—Ä–µ–¥—å –ø—É–±–ª–∏–∫–∞—Ü–∏–π
/publish - –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â—É—é –Ω–æ–≤–æ—Å—Ç—å

–ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞–µ—Ç –Ω–æ–≤–æ—Å—Ç–∏ –∏–∑ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏—Ö —Å –ø–æ–º–æ—â—å—é AI –∏ –ø—É–±–ª–∏–∫—É–µ—Ç –≤ –≤–∞—à –∫–∞–Ω–∞–ª.
        """
        
        await update.message.reply_text(welcome_message, parse_mode=ParseMode.MARKDOWN)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = """
üìö **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:**

/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/status - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
/queue - –ü–æ–∫–∞–∑–∞—Ç—å –æ—á–µ—Ä–µ–¥—å –ø—É–±–ª–∏–∫–∞—Ü–∏–π
/publish - –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â—É—é –Ω–æ–≤–æ—Å—Ç—å –∏–∑ –æ—á–µ—Ä–µ–¥–∏

**–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –±–æ—Ç:**
1. –°–æ–±–∏—Ä–∞–µ—Ç –Ω–æ–≤–æ—Å—Ç–∏ –∏–∑ RSS, Telegram –∫–∞–Ω–∞–ª–æ–≤, Reddit
2. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç —Å –ø–æ–º–æ—â—å—é Ollama AI
3. –ú–æ–¥–µ—Ä–∏—Ä—É–µ—Ç –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç
4. –ü—É–±–ª–∏–∫—É–µ—Ç –≤ –≤–∞—à –∫–∞–Ω–∞–ª

**–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –Ω–æ–≤–æ—Å—Ç–µ–π:**
‚Ä¢ Formula 1 Official
‚Ä¢ Motorsport.com
‚Ä¢ Autosport
‚Ä¢ Reddit r/formula1
‚Ä¢ Telegram –∫–∞–Ω–∞–ª—ã
        """
        
        await update.message.reply_text(help_message, parse_mode=ParseMode.MARKDOWN)
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command"""
        try:
            # Get system status (this would typically come from the main system)
            status_message = """
üìä **–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã:**

üü¢ **–°–±–æ—Ä—â–∏–∫ –Ω–æ–≤–æ—Å—Ç–µ–π:** –ê–∫—Ç–∏–≤–µ–Ω
üü¢ **AI –æ–±—Ä–∞–±–æ—Ç–∫–∞:** –ê–∫—Ç–∏–≤–Ω–∞
üü¢ **–ú–æ–¥–µ—Ä–∞—Ü–∏—è:** –ê–∫—Ç–∏–≤–Ω–∞
üü¢ **–ü—É–±–ª–∏–∫–∞—Ü–∏—è:** –ê–∫—Ç–∏–≤–Ω–∞

üìà **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
‚Ä¢ –ù–æ–≤–æ—Å—Ç–µ–π —Å–æ–±—Ä–∞–Ω–æ: 0
‚Ä¢ –ù–æ–≤–æ—Å—Ç–µ–π –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: 0
‚Ä¢ –ù–æ–≤–æ—Å—Ç–µ–π –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ: 0
‚Ä¢ –í –æ—á–µ—Ä–µ–¥–∏: 0

‚è∞ **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:** –°–µ–π—á–∞—Å
            """
            
            await update.message.reply_text(status_message, parse_mode=ParseMode.MARKDOWN)
            
        except Exception as e:
            logger.error(f"Error in status command: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞")
    
    async def queue_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /queue command"""
        try:
            if not self.pending_publications:
                await update.message.reply_text("üì≠ –û—á–µ—Ä–µ–¥—å –ø—É–±–ª–∏–∫–∞—Ü–∏–π –ø—É—Å—Ç–∞")
                return
            
            queue_message = "üìã **–û—á–µ—Ä–µ–¥—å –ø—É–±–ª–∏–∫–∞—Ü–∏–π:**\n\n"
            
            for i, item in enumerate(self.pending_publications[:5], 1):
                queue_message += f"{i}. **{item.title[:50]}...**\n"
                queue_message += f"   –ò—Å—Ç–æ—á–Ω–∏–∫: {item.source}\n"
                queue_message += f"   –†–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å: {item.relevance_score:.2f}\n"
                queue_message += f"   –í–∞–∂–Ω–æ—Å—Ç—å: {item.importance_level}/5\n\n"
            
            if len(self.pending_publications) > 5:
                queue_message += f"... –∏ –µ—â–µ {len(self.pending_publications) - 5} –Ω–æ–≤–æ—Å—Ç–µ–π"
            
            await update.message.reply_text(queue_message, parse_mode=ParseMode.MARKDOWN)
            
        except Exception as e:
            logger.error(f"Error in queue command: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—á–µ—Ä–µ–¥–∏")
    
    async def publish_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /publish command"""
        try:
            if not self.pending_publications:
                await update.message.reply_text("üì≠ –ù–µ—Ç –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏")
                return
            
            # Get next item from queue
            next_item = self.pending_publications.pop(0)
            
            # Create publication message
            message = self._format_news_message(next_item)
            
            # Create inline keyboard for approval
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data=f"publish_{next_item.id}"),
                    InlineKeyboardButton("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject_{next_item.id}")
                ],
                [
                    InlineKeyboardButton("üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit_{next_item.id}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                f"üì∞ **–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä:**\n\n{message}",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=reply_markup
            )
            
        except Exception as e:
            logger.error(f"Error in publish command: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏")
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button callbacks"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        action, item_id = data.split('_', 1)
        
        try:
            if action == "publish":
                await self._handle_publish(item_id, query)
            elif action == "reject":
                await self._handle_reject(item_id, query)
            elif action == "edit":
                await self._handle_edit(item_id, query)
                
        except Exception as e:
            logger.error(f"Error handling button callback: {e}")
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã")
    
    async def _handle_publish(self, item_id: str, query):
        """Handle publish action"""
        try:
            # Find the item in pending publications
            item = next((item for item in self.pending_publications if item.id == item_id), None)
            
            if not item:
                await query.edit_message_text("‚ùå –ù–æ–≤–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                return
            
            # Publish to channel
            result = await self.publish_to_channel(item)
            
            if result.success:
                await query.edit_message_text("‚úÖ –ù–æ–≤–æ—Å—Ç—å —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞!")
            else:
                await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {result.error_message}")
                
        except Exception as e:
            logger.error(f"Error handling publish: {e}")
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏")
    
    async def _handle_reject(self, item_id: str, query):
        """Handle reject action"""
        try:
            # Remove from pending publications
            self.pending_publications = [item for item in self.pending_publications if item.id != item_id]
            await query.edit_message_text("‚ùå –ù–æ–≤–æ—Å—Ç—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞")
            
        except Exception as e:
            logger.error(f"Error handling reject: {e}")
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è")
    
    async def _handle_edit(self, item_id: str, query):
        """Handle edit action"""
        await query.edit_message_text("üìù –§—É–Ω–∫—Ü–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ")
    
    def _format_news_message(self, news_item: ProcessedNewsItem) -> str:
        """Format news item for publication"""
        message = f"üèéÔ∏è **{news_item.title}**\n\n"
        
        if news_item.summary:
            message += f"üìù {news_item.summary}\n\n"
        
        if news_item.key_points:
            message += "üîë **–ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:**\n"
            for point in news_item.key_points[:3]:  # Show max 3 points
                message += f"‚Ä¢ {point}\n"
            message += "\n"
        
        if news_item.formatted_content:
            message += f"{news_item.formatted_content}\n\n"
        
        message += f"üì∞ –ò—Å—Ç–æ—á–Ω–∏–∫: {news_item.source}\n"
        message += f"üîó [–ß–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é]({news_item.url})"
        
        if news_item.tags:
            tags_str = " ".join([f"#{tag.replace(' ', '_')}" for tag in news_item.tags[:5]])
            message += f"\n\n{tags_str}"
        
        return message
    
    async def publish_to_channel(self, news_item: ProcessedNewsItem) -> PublicationResult:
        """Publish news item to channel"""
        try:
            message = self._format_news_message(news_item)
            
            # Send to channel
            sent_message = await self.bot.send_message(
                chat_id=self.channel_id,
                text=message,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=False
            )
            
            return PublicationResult(
                success=True,
                message_id=str(sent_message.message_id)
            )
            
        except Exception as e:
            logger.error(f"Error publishing to channel: {e}")
            return PublicationResult(
                success=False,
                error_message=str(e)
            )
    
    async def add_to_pending(self, news_item: ProcessedNewsItem):
        """Add news item to pending publications"""
        self.pending_publications.append(news_item)
        logger.info(f"Added to pending publications: {news_item.title[:50]}...")
    
    async def run(self):
        """Run the bot"""
        try:
            await self.application.run_polling()
        except Exception as e:
            logger.error(f"Error running bot: {e}")
    
    async def stop(self):
        """Stop the bot"""
        if self.application:
            await self.application.stop()
        logger.info("Telegram bot stopped")
